# 并发控制器

<div class="tip custom-block">

视频讲解

* [抖音](https://www.douyin.com/user/self?from_tab_name=main&modal_id=7416331503614954761&showTab=post)
* [哔哩哔哩](https://www.bilibili.com/video/BV1K7tXenEwG/?spm_id_from=333.1387.search.video_card.click)

</div>

## 1. 问题场景

假设我们要上传一个 20GB 的大文件，将其分成 100 个 10MB 的分片。如果不使用任务调度器，同时发起 100 个上传请求会导致以下问题：

1. **浏览器的并发请求数量被占满** - 浏览器对同一域名的并发请求有限制（通常为 6-8 个）
2. **其他正常业务请求可能无法及时发送** - 所有连接被文件上传占用
3. **服务器压力过大** - 同时处理大量请求可能导致服务器响应缓慢或崩溃
4. **网络带宽被占满** - 大量并发上传会消耗所有可用带宽

## 2. 解决方案

我们可以尝试着将所有的任务，都放到一个队列里面去，这样我们每次最多发送两个请求，如果有一个请求发送完成，那么我们再从这个队列里面取出一个发送请求，我们只需要保证同时发送的请求不超过两个，这样就可以保证并发数量不被占满，也不会占用过多的带宽。

## 3. 实现原理

并发控制器的核心思想是：

- 维护一个任务队列
- 控制同时执行的任务数量
- 当有任务完成时，自动从队列中取出新任务执行

## 4. 代码实现

```javascript
/**
 * 任务调度器类
 * 用于控制并发任务的执行数量
 */
class TaskScheduler {
    tasks = [] // 待执行任务队列
    runningCount = 0 // 当前正在运行的任务数量
    maxRunning = Infinity // 最大并发任务数量

    /**
     * 构造函数
     * @param {number} maxRunning 最大并发数，默认为无限制
     */
    constructor(maxRunning = Infinity) {
    // 如果传入0，则设为无限制
        this.maxRunning = maxRunning === 0 ? Infinity : maxRunning
    }

    /**
     * 执行任务的核心方法
     * 检查是否可以执行新任务，如果可以则从队列中取出并执行
     */
    run() {
    // 如果当前运行的任务数已达到最大值，则不执行新任务
        if (this.runningCount >= this.maxRunning) {
            return
        }
        // 如果任务队列为空，则无任务可执行
        if (this.tasks.length === 0) {
            return
        }

        // 增加运行中任务计数
        this.runningCount++
        // 从队列头部取出一个任务
        const task = this.tasks.shift()

        // 执行任务，无论成功或失败都会在完成后递归调用run方法
        task().finally(() => {
            this.runningCount-- // 任务完成，减少运行中任务计数
            this.run() // 尝试执行下一个任务
        })
    }

    /**
     * 添加任务到调度器
     * @param {Function} task 要执行的任务函数，应返回Promise
     * @returns {Promise} 返回Promise，在任务完成时resolve
     */
    addTask(task) {
        return new Promise((resolve, reject) => {
            // 将任务包装后添加到队列中
            this.tasks.push(() => task().then(resolve).catch(reject))
            // this.tasks.push(() => task().then(resolve, reject)); // 另一种写法

            // 尝试立即执行任务
            this.run()
        })
    }
}
```

## 5. 使用示例

### 基础使用

```javascript
// 创建一个最大并发数为2的调度器实例
const scheduler = new TaskScheduler(2)

// 辅助函数：创建延时Promise
const sleep = time => new Promise(resolve => setTimeout(resolve, time))

// 开始计时
console.time('task1')
console.time('task2')
console.time('task3')
console.time('task4')
console.time('task5')

// 添加5个任务到调度器，每个任务耗时1秒
// 由于最大并发数为2，所以会分批执行：前2个并行，后3个排队
scheduler.addTask(() => sleep(1000).then(() => console.timeEnd('task1')))
scheduler.addTask(() => sleep(1000).then(() => console.timeEnd('task2')))
scheduler.addTask(() => sleep(1000).then(() => console.timeEnd('task3')))
scheduler.addTask(() => sleep(1000).then(() => console.timeEnd('task4')))
scheduler.addTask(() => sleep(1000).then(() => console.timeEnd('task5')))
```

### 文件上传场景

```javascript
// 创建文件上传调度器，最大并发数为3
const uploadScheduler = new TaskScheduler(3)

// 模拟文件分片上传
function uploadChunk(chunkData, chunkIndex) {
    return fetch('/upload', {
        method: 'POST',
        body: chunkData,
        headers: {
            'Content-Type': 'application/octet-stream',
            'X-Chunk-Index': chunkIndex,
        },
    })
}

// 上传100个分片，但同时只有3个在上传
const chunks = Array.from({ length: 100 }, (_, i) => i)
const uploadPromises = chunks.map((chunkIndex) => {
    return uploadScheduler.addTask(() => {
        console.log(`开始上传分片 ${chunkIndex}`)
        return uploadChunk(getChunkData(chunkIndex), chunkIndex).then(() => console.log(`分片 ${chunkIndex} 上传完成`))
    })
})

// 等待所有分片上传完成
Promise.all(uploadPromises)
    .then(() => console.log('所有分片上传完成'))
    .catch(err => console.error('上传失败:', err))
```

## 6. 执行效果

使用并发控制器后：

- **控制并发数量**：同时最多只有指定数量的请求在执行
- **自动队列管理**：任务完成后自动执行下一个排队的任务
- **资源合理利用**：避免浏览器连接数限制和服务器压力过大
- **带宽优化**：合理分配网络带宽，不影响其他业务请求

通过这种方式，我们可以有效地控制大文件上传的并发数量，既保证了上传效率，又避免了资源过度占用的问题。
